<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.RunWars&quot;&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.android.geo.API_KEY&quot;&#10;            android:value=&quot;${MAPS_API_KEY}&quot;/&gt;&#10;&#10;        &lt;!-- Default notification icon for all notifications --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.firebase.messaging.default_notification_icon&quot;&#10;            android:resource=&quot;@drawable/ic_stat_name&quot; /&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.firebase.messaging.default_notification_color&quot;&#10;            android:resource=&quot;@android:color/transparent&quot; /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.services.LocationTrackingService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;location&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.RunWars&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.RunWars&quot;&gt;&#13;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.android.geo.API_KEY&quot;&#10;            android:value=&quot;${MAPS_API_KEY}&quot;/&gt;&#10;&#10;        &lt;!-- Default notification icon for all notifications --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.firebase.messaging.default_notification_icon&quot;&#10;            android:resource=&quot;@drawable/ic_stat_name&quot; /&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.firebase.messaging.default_notification_color&quot;&#10;            android:resource=&quot;@android:color/transparent&quot; /&gt;&#10;&#10;        &lt;service&#13;&#10;            android:name=&quot;.services.LocationTrackingService&quot;&#13;&#10;            android:enabled=&quot;true&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:foregroundServiceType=&quot;location&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:label=&quot;@string/app_name&quot;&#13;&#10;            android:theme=&quot;@style/Theme.RunWars&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/HomeScreen.kt" />
              <option name="originalContent" value="package tech.titans.runwars&#10;&#10;import android.Manifest&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.systemBars&#10;import androidx.compose.foundation.layout.windowInsetsPadding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.core.content.ContextCompat&#10;import androidx.navigation.NavController&#10;import com.google.android.gms.location.*&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.maps.android.compose.*&#10;import kotlinx.coroutines.launch&#10;import tech.titans.runwars.services.LocationTrackingService&#10;import tech.titans.runwars.services.UserService&#10;import tech.titans.runwars.utils.BatteryOptimizationHelper&#10;import tech.titans.runwars.utils.LocationUtils.calculateCapturedArea&#10;import tech.titans.runwars.utils.LocationUtils.createUserMarkerBitmap&#10;import tech.titans.runwars.utils.LocationUtils.isClosedLoop&#10;&#10;@Composable&#10;fun HomeScreen(navController: NavController) {&#10;    val userId = FirebaseAuth.getInstance().currentUser!!.uid&#10;    val context = LocalContext.current&#10;    val fusedLocationClient: FusedLocationProviderClient =&#10;        LocationServices.getFusedLocationProviderClient(context)&#10;&#10;    // Service binding&#10;    var locationService by remember { mutableStateOf&lt;LocationTrackingService?&gt;(null) }&#10;    var serviceBound by remember { mutableStateOf(false) }&#10;&#10;    // UI state from service&#10;    var currentLocation by remember { mutableStateOf(LatLng(46.7712, 23.6236)) }&#10;    var isRunning by remember { mutableStateOf(false) }&#10;    var isPaused by remember { mutableStateOf(false) }&#10;    var pathPoints by remember { mutableStateOf(listOf&lt;LatLng&gt;()) }&#10;    var pathSegments by remember { mutableStateOf(listOf&lt;List&lt;LatLng&gt;&gt;()) }&#10;    var distanceMeters by remember { mutableStateOf(0.0) }&#10;    var capturedAreaMeters2 by remember { mutableStateOf&lt;Double?&gt;(null) }&#10;    var showResultDialog by remember { mutableStateOf(false) }&#10;    var continueRun by remember { mutableStateOf(false) }&#10;&#10;    // Permission dialogs&#10;    var showBatteryOptimizationDialog by remember { mutableStateOf(false) }&#10;    var showBackgroundLocationDialog by remember { mutableStateOf(false) }&#10;&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = com.google.android.gms.maps.model.CameraPosition.fromLatLngZoom(currentLocation, 14f)&#10;    }&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Service connection&#10;    val serviceConnection = remember {&#10;        object : ServiceConnection {&#10;            override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {&#10;                val locationBinder = binder as? LocationTrackingService.LocationBinder&#10;                locationService = locationBinder?.getService()&#10;                serviceBound = true&#10;                println(&quot;✅ Service connected&quot;)&#10;            }&#10;&#10;            override fun onServiceDisconnected(name: ComponentName?) {&#10;                locationService = null&#10;                serviceBound = false&#10;                println(&quot;❌ Service disconnected&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Background location permission launcher (for Android 10+)&#10;    val backgroundLocationPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            if (granted) {&#10;                println(&quot;✅ Background location permission granted&quot;)&#10;                // Check battery optimization after background permission&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    if (!BatteryOptimizationHelper.isBatteryOptimizationDisabled(context)) {&#10;                        showBatteryOptimizationDialog = true&#10;                    }&#10;                }&#10;            } else {&#10;                println(&quot;❌ Background location permission denied&quot;)&#10;            }&#10;        }&#10;    )&#10;&#10;    // Notification permission launcher (for Android 13+)&#10;    val notificationPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            if (granted) {&#10;                println(&quot;✅ Notification permission granted&quot;)&#10;            }&#10;        }&#10;    )&#10;&#10;    // Location permission launcher&#10;    val locationPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            if (granted) {&#10;                if (ContextCompat.checkSelfPermission(&#10;                        context,&#10;                        Manifest.permission.ACCESS_FINE_LOCATION&#10;                    ) == PackageManager.PERMISSION_GRANTED&#10;                ) {&#10;                    fusedLocationClient.lastLocation.addOnSuccessListener { location -&gt;&#10;                        location?.let {&#10;                            val newLocation = LatLng(it.latitude, it.longitude)&#10;                            currentLocation = newLocation&#10;                            cameraPositionState.position =&#10;                                com.google.android.gms.maps.model.CameraPosition.fromLatLngZoom(newLocation, 15f)&#10;                        }&#10;                    }&#10;&#10;                    // Request background location permission for Android 10+ (only if not already granted)&#10;                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                        val backgroundLocationGranted = ContextCompat.checkSelfPermission(&#10;                            context,&#10;                            Manifest.permission.ACCESS_BACKGROUND_LOCATION&#10;                        ) == PackageManager.PERMISSION_GRANTED&#10;&#10;                        if (!backgroundLocationGranted) {&#10;                            showBackgroundLocationDialog = true&#10;                        } else {&#10;                            // Background permission already granted, check battery optimization&#10;                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                                if (!BatteryOptimizationHelper.isBatteryOptimizationDisabled(context)) {&#10;                                    showBatteryOptimizationDialog = true&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Passive location request - for position updates when not running&#10;    val passiveLocationRequest = remember {&#10;        LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 10_000L)&#10;            .setMinUpdateIntervalMillis(5_000L)&#10;            .build()&#10;    }&#10;&#10;    // Location callback for passive position updates (when not running)&#10;    val passiveLocationCallback = remember {&#10;        object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                if (isRunning) return // Don't update if we're actively tracking&#10;&#10;                val loc = result.lastLocation ?: return&#10;                val newLocation = LatLng(loc.latitude, loc.longitude)&#10;                currentLocation = newLocation&#10;                println(&quot; Passive position updated: ${newLocation.latitude}, ${newLocation.longitude}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Sync state from service&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.isTracking.collect { tracking -&gt;&#10;                isRunning = tracking&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.isPaused.collect { paused -&gt;&#10;                isPaused = paused&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.pathPoints.collect { points -&gt;&#10;                pathPoints = points&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.pathSegments.collect { segments -&gt;&#10;                pathSegments = segments&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.distanceMeters.collect { distance -&gt;&#10;                distanceMeters = distance&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.currentLocation.collect { location -&gt;&#10;                location?.let {&#10;                    currentLocation = it&#10;                    // Don't auto-center camera during run - let user control zoom/pan&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    val userMarkerState = rememberMarkerState(position = currentLocation)&#10;&#10;    // Update marker position when current location changes&#10;    LaunchedEffect(currentLocation) {&#10;        userMarkerState.position = currentLocation&#10;    }&#10;&#10;    // Background location permission dialog&#10;    if (showBackgroundLocationDialog &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;        AlertDialog(&#10;            onDismissRequest = { showBackgroundLocationDialog = false },&#10;            title = { Text(&quot;Background Location Permission&quot;) },&#10;            text = {&#10;                Text(&#10;                    &quot;To track your runs accurately even when the app is in the background or closed, &quot; +&#10;                    &quot;RunWars needs access to your location all the time.\n\n&quot; +&#10;                    &quot;Please select 'Allow all the time' on the next screen.&quot;&#10;                )&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showBackgroundLocationDialog = false&#10;                        backgroundLocationPermissionLauncher.launch(Manifest.permission.ACCESS_BACKGROUND_LOCATION)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Continue&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showBackgroundLocationDialog = false }) {&#10;                    Text(&quot;Skip&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Battery optimization dialog&#10;    if (showBatteryOptimizationDialog &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;        AlertDialog(&#10;            onDismissRequest = { showBatteryOptimizationDialog = false },&#10;            title = { Text(&quot;Disable Battery Optimization&quot;) },&#10;            text = {&#10;                Text(&#10;                    &quot;To ensure continuous GPS tracking during your runs, please disable &quot; +&#10;                    &quot;battery optimization for RunWars.\n\n&quot; +&#10;                    &quot;This prevents Android from stopping location updates to save battery.&quot;&#10;                )&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showBatteryOptimizationDialog = false&#10;                        BatteryOptimizationHelper.requestDisableBatteryOptimization(context)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Open Settings&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showBatteryOptimizationDialog = false }) {&#10;                    Text(&quot;Skip&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Result dialog after run&#10;    LaunchedEffect(Unit) {&#10;        // Bind to location service&#10;        val intent = Intent(context, LocationTrackingService::class.java)&#10;        context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;&#10;        // Request permissions&#10;        locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;&#10;        // Request notification permission for Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;        }&#10;&#10;        // Start passive location updates for when not running&#10;        try {&#10;            if (ContextCompat.checkSelfPermission(&#10;                    context,&#10;                    Manifest.permission.ACCESS_FINE_LOCATION&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                fusedLocationClient.requestLocationUpdates(&#10;                    passiveLocationRequest,&#10;                    passiveLocationCallback,&#10;                    Looper.getMainLooper()&#10;                )&#10;                println(&quot;✅ Passive location updates started&quot;)&#10;            }&#10;        } catch (e: SecurityException) {&#10;            println(&quot;❌ Could not start passive location updates: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Cleanup location updates when leaving screen&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            fusedLocationClient.removeLocationUpdates(passiveLocationCallback)&#10;            context.unbindService(serviceConnection)&#10;            println(&quot;️ Service unbound&quot;)&#10;        }&#10;    }&#10;&#10;    // Result dialog after run&#10;    if (showResultDialog &amp;&amp; capturedAreaMeters2 != null) {&#10;        val isLoop = isClosedLoop(pathPoints)&#10;&#10;        AlertDialog(&#10;            onDismissRequest = {&#10;                showResultDialog = false&#10;                continueRun = true&#10;                // Resume tracking through service&#10;                if (serviceBound &amp;&amp; locationService != null) {&#10;                    locationService!!.continueTracking(pathPoints, distanceMeters)&#10;                    locationService!!.startTracking()&#10;                }&#10;            },&#10;            title = {&#10;                Text(&#10;                    if (isLoop) &quot;Territory Captured!&quot; else &quot;Run Completed&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;            },&#10;            text = {&#10;                Column {&#10;                    Text(&quot;Distance: %.2f km&quot;.format(distanceMeters / 1000))&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    if (isLoop &amp;&amp; capturedAreaMeters2!! &gt; 0) {&#10;                        Text(&quot;Territory: %.2f ha&quot;.format(&#10;                            capturedAreaMeters2!! / 10_000&#10;                        ))&#10;                    } else {&#10;                        Text(&#10;                            &quot;⚠️ You need to run in a loop to capture territory!&quot;,&#10;                            color = Color(0xFFFF9800),&#10;                            fontSize = 14.sp,&#10;                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                        )&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Text(&#10;                            &quot;Tip: End your run close to where you started (within 50m)&quot;,&#10;                            color = Color.Gray,&#10;                            fontSize = 12.sp&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ){&#10;                    if (isLoop &amp;&amp; capturedAreaMeters2!! &gt; 0) {&#10;                        Button(&#10;                            onClick = {&#10;                                showResultDialog = false&#10;                                UserService.addRunSessionToUser(distanceMeters, pathPoints, userId)&#10;                                // Reset service&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.resetTracking()&#10;                                }&#10;                                continueRun = false&#10;                            },&#10;                            colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF2D3E6F))&#10;                        ) {&#10;                            Text(&quot;Save Territory&quot;)&#10;                        }&#10;                        TextButton(onClick = {&#10;                            showResultDialog = false&#10;                            // Reset service&#10;                            if (serviceBound &amp;&amp; locationService != null) {&#10;                                locationService!!.resetTracking()&#10;                            }&#10;                            capturedAreaMeters2 = null&#10;                            continueRun = false&#10;                        }) {&#10;                            Text(&quot;Discard&quot;)&#10;                        }&#10;                    } else {&#10;                        if(pathPoints.size &gt;= 3) {&#10;                            Button(&#10;                                onClick = {&#10;                                    showResultDialog = false&#10;                                    UserService.addRunSessionToUser(distanceMeters, pathPoints, userId)&#10;                                    // Reset service&#10;                                    if (serviceBound &amp;&amp; locationService != null) {&#10;                                        locationService!!.resetTracking()&#10;                                    }&#10;                                    continueRun = false&#10;                                },&#10;                                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF2D3E6F))&#10;                            ) {&#10;                                Text(&quot;Save the run anyway&quot;)&#10;                            }&#10;                        }&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Button(&#10;                                onClick = {&#10;                                    showResultDialog = false&#10;                                    continueRun = true&#10;                                    // Resume tracking through service&#10;                                    if (serviceBound &amp;&amp; locationService != null) {&#10;                                        locationService!!.continueTracking(pathPoints, distanceMeters)&#10;                                        locationService!!.startTracking()&#10;                                    }&#10;                                },&#10;                                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF757575))&#10;                            ) {&#10;                                Text(&quot;Continue&quot;)&#10;                            }&#10;                            TextButton(onClick = {&#10;                                showResultDialog = false&#10;                                // Reset service&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.resetTracking()&#10;                                }&#10;                                capturedAreaMeters2 = null&#10;                                continueRun = false&#10;                            }) {&#10;                                Text(&quot;Discard&quot;)&#10;                            }&#10;                        }&#10;&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        gesturesEnabled = drawerState.isOpen,&#10;        drawerContent = {&#10;            ModalDrawerSheet(&#10;                drawerContainerColor = Color(0xFF1E2A47),&#10;                modifier = Modifier.width(280.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxHeight()&#10;                ) {&#10;                    // Header&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;RunWars&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        color = Color.White,&#10;                        fontSize = 24.sp,&#10;                        style = MaterialTheme.typography.headlineMedium&#10;                    )&#10;                    HorizontalDivider(color = Color.White.copy(alpha = 0.2f))&#10;                    &#10;                    // Menu items&#10;                    listOf(&quot;Profile&quot;, &quot;Statistics&quot;, &quot;Leaderboard&quot;, &quot;Settings&quot;).forEach {&#10;                        NavigationDrawerItem(&#10;                            label = { Text(it, color = Color.White) },&#10;                            selected = false,&#10;                            onClick = {},&#10;                            modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp),&#10;                            colors = NavigationDrawerItemDefaults.colors(&#10;                                unselectedContainerColor = Color.Transparent,&#10;                                selectedContainerColor = Color(0xFF2D3E6F)&#10;                            )&#10;                        )&#10;                    }&#10;                    &#10;                    // Spacer to push logout to bottom&#10;                    Spacer(modifier = Modifier.weight(1f))&#10;                    &#10;                    HorizontalDivider(color = Color.White.copy(alpha = 0.2f))&#10;                    &#10;                    // Logout button&#10;                    NavigationDrawerItem(&#10;                        label = { &#10;                            Row(&#10;                                verticalAlignment = Alignment.CenterVertically,&#10;                                horizontalArrangement = Arrangement.Start&#10;                            ) {&#10;                                Icon(&#10;                                    painter = painterResource(id = android.R.drawable.ic_menu_close_clear_cancel),&#10;                                    contentDescription = &quot;Logout&quot;,&#10;                                    tint = Color(0xFFFF6B6B),&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                                Spacer(modifier = Modifier.width(12.dp))&#10;                                Text(&#10;                                    &quot;Logout&quot;, &#10;                                    color = Color(0xFFFF6B6B),&#10;                                    fontWeight = androidx.compose.ui.text.font.FontWeight.Medium&#10;                                )&#10;                            }&#10;                        },&#10;                        selected = false,&#10;                        onClick = {&#10;                            scope.launch {&#10;                                drawerState.close()&#10;                                &#10;                                // Clear &quot;stay logged in&quot; preference&#10;                                val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, android.content.Context.MODE_PRIVATE)&#10;                                prefs.edit().putBoolean(&quot;stayLoggedIn&quot;, false).apply()&#10;                                &#10;                                // Sign out from Firebase&#10;                                com.google.firebase.auth.FirebaseAuth.getInstance().signOut()&#10;                                &#10;                                // Navigate to login screen and clear back stack&#10;                                navController.navigate(&quot;login&quot;) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = true }&#10;                                }&#10;                            }&#10;                        },&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),&#10;                        colors = NavigationDrawerItemDefaults.colors(&#10;                            unselectedContainerColor = Color.Transparent,&#10;                            selectedContainerColor = Color(0xFF2D3E6F)&#10;                        )&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;            }&#10;        }&#10;    ) {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;&#10;            // Google Map&#10;            GoogleMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                cameraPositionState = cameraPositionState,&#10;                uiSettings = MapUiSettings(zoomControlsEnabled = false)&#10;            ) {&#10;                // Custom user position marker&#10;                Marker(&#10;                    state = userMarkerState,&#10;                    title = if (isRunning) &quot;Running...&quot; else &quot;You&quot;,&#10;                    icon = BitmapDescriptorFactory.fromBitmap(createUserMarkerBitmap(isRunning)),&#10;                    anchor = Offset(0.5f, 0.5f),&#10;                    flat = true&#10;                )&#10;&#10;                // Running path (multiple polylines for segments)&#10;                // Each segment is drawn separately to show breaks when pause gap &gt; 50m&#10;                for (segment in pathSegments) {&#10;                    if (segment.size &gt;= 2) {&#10;                        Polyline(&#10;                            points = segment,&#10;                            color = if (isRunning) Color.Cyan else Color(0xFF2D3E6F),&#10;                            width = 8f&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Show captured territory when run is finished AND it forms a loop&#10;                if (!isRunning &amp;&amp; pathPoints.size &gt;= 3 &amp;&amp; isClosedLoop(pathPoints)) {&#10;                    val closedPath = if (pathPoints.first() != pathPoints.last()) {&#10;                        pathPoints + pathPoints.first()&#10;                    } else {&#10;                        pathPoints&#10;                    }&#10;&#10;                    Polygon(&#10;                        points = closedPath,&#10;                        fillColor = Color(0x552D3E6F),&#10;                        strokeColor = Color(0xFF2D3E6F),&#10;                        strokeWidth = 4f&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Dimming overlay when paused&#10;            if (isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.3f))&#10;                )&#10;            }&#10;&#10;            // Menu button (top right)&#10;            Surface(&#10;                onClick = {&#10;                    scope.launch {&#10;                        if (drawerState.isOpen) drawerState.close() else drawerState.open()&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .windowInsetsPadding(WindowInsets.systemBars)&#10;                    .padding(16.dp)&#10;                    .size(48.dp),&#10;                shape = androidx.compose.foundation.shape.CircleShape,&#10;                color = Color(0xFF1E2A47),&#10;                shadowElevation = 4.dp&#10;            ) {&#10;                Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Menu,&#10;                        contentDescription = &quot;Menu&quot;,&#10;                        tint = Color.White,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Distance display (top left)&#10;            if (isRunning || pathPoints.isNotEmpty()) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopStart)&#10;                        .windowInsetsPadding(WindowInsets.systemBars)&#10;                        .padding(16.dp)&#10;                        .background(Color(0xDD1E2A47), RoundedCornerShape(12.dp))&#10;                        .padding(horizontal = 16.dp, vertical = 12.dp)&#10;                ) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        if (isRunning &amp;&amp; !isPaused) {&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .size(8.dp)&#10;                                    .background(Color.Green, androidx.compose.foundation.shape.CircleShape)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;                        Text(&#10;                            text = when {&#10;                                isPaused -&gt; &quot;PAUSED&quot;&#10;                                isRunning -&gt; &quot;RUNNING&quot;&#10;                                else -&gt; &quot;FINISHED&quot;&#10;                            },&#10;                            color = when {&#10;                                isPaused -&gt; Color(0xFFFF9800)&#10;                                isRunning -&gt; Color.Green&#10;                                else -&gt; Color.White&#10;                            },&#10;                            fontSize = 12.sp,&#10;                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                        )&#10;                    }&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Text(&#10;                        text = &quot;%.2f km&quot;.format(distanceMeters / 1000),&#10;                        color = Color.White,&#10;                        fontSize = 28.sp,&#10;                        fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                    )&#10;                    if (!isRunning &amp;&amp; capturedAreaMeters2 != null &amp;&amp; capturedAreaMeters2!! &gt; 0 &amp;&amp; isClosedLoop(pathPoints)) {&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Text(&#10;                            text = &quot;Territory: %.2f ha&quot;.format(capturedAreaMeters2!! / 10_000),&#10;                            color = Color.Cyan,&#10;                            fontSize = 16.sp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Recenter map FAB - show when running and (zoomed out OR user panned away)&#10;            // Calculate distance between camera center and user's actual location&#10;            val cameraCenterLat = cameraPositionState.position.target.latitude&#10;            val cameraCenterLng = cameraPositionState.position.target.longitude&#10;            val userLat = currentLocation.latitude&#10;            val userLng = currentLocation.longitude&#10;&#10;            // Calculate distance in meters using Haversine formula&#10;            val earthRadius = 6371000.0 // meters&#10;            val dLat = Math.toRadians(userLat - cameraCenterLat)&#10;            val dLng = Math.toRadians(userLng - cameraCenterLng)&#10;            val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;                    Math.cos(Math.toRadians(cameraCenterLat)) * Math.cos(Math.toRadians(userLat)) *&#10;                    Math.sin(dLng / 2) * Math.sin(dLng / 2)&#10;            val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))&#10;            val distanceFromCenter = earthRadius * c&#10;&#10;            // Show button if zoomed out (&lt; 15) OR if user is more than 100 meters away from their location&#10;            val shouldShowRecenterButton = isRunning &amp;&amp; (cameraPositionState.position.zoom &lt; 15f || distanceFromCenter &gt; 100)&#10;&#10;            if (shouldShowRecenterButton) {&#10;                FloatingActionButton(&#10;                    onClick = {&#10;                        scope.launch {&#10;                            cameraPositionState.animate(&#10;                                com.google.android.gms.maps.CameraUpdateFactory.newLatLngZoom(&#10;                                    currentLocation,&#10;                                    16f&#10;                                ),&#10;                                durationMs = 500&#10;                            )&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomEnd)&#10;                        .windowInsetsPadding(WindowInsets.navigationBars)&#10;                        .padding(end = 16.dp, bottom = 100.dp),&#10;                    containerColor = Color(0xFF1E2A47),&#10;                    contentColor = Color.White,&#10;                    elevation = FloatingActionButtonDefaults.elevation(&#10;                        defaultElevation = 6.dp,&#10;                        pressedElevation = 12.dp&#10;                    )&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.LocationOn,&#10;                        contentDescription = &quot;Recenter Map&quot;,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Start/Finish button (bottom)&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.BottomCenter)&#10;                    .background(Color(0xEE1E2A47))&#10;                    .windowInsetsPadding(WindowInsets.navigationBars)&#10;            ) {&#10;                if (isRunning) {&#10;                    // When running, show two buttons: Pause/Resume and Finish&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 24.dp, vertical = 12.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Pause/Resume button&#10;                        Button(&#10;                            onClick = {&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    if (isPaused) {&#10;                                        println(&quot;▶️ Resuming run...&quot;)&#10;                                        locationService!!.resumeTracking()&#10;                                    } else {&#10;                                        println(&quot;⏸️ Pausing run...&quot;)&#10;                                        locationService!!.pauseTracking()&#10;                                    }&#10;                                }&#10;                            },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .height(56.dp),&#10;                            shape = RoundedCornerShape(28.dp),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = if (isPaused) Color(0xFF4CAF50) else Color(0xFFFF9800)&#10;                            )&#10;                        ) {&#10;                            Text(&#10;                                if (isPaused) &quot;RESUME&quot; else &quot;PAUSE&quot;,&#10;                                color = Color.White,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                            )&#10;                        }&#10;&#10;                        // Finish button&#10;                        Button(&#10;                            onClick = {&#10;                                println(&quot; Finishing run via service...&quot;)&#10;&#10;                                // Stop service tracking&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.stopTracking()&#10;                                }&#10;&#10;                                // Calculate captured territory only if it's a closed loop&#10;                                capturedAreaMeters2 =&#10;                                    if (pathPoints.size &gt;= 3 &amp;&amp; isClosedLoop(pathPoints)) {&#10;                                        calculateCapturedArea(pathPoints)&#10;                                    } else {&#10;                                        0.0&#10;                                    }&#10;&#10;                                // Show result dialog&#10;                                showResultDialog = true&#10;                            },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .height(56.dp),&#10;                            shape = RoundedCornerShape(28.dp),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = Color(0xFFD32F2F)&#10;                            )&#10;                        ) {&#10;                            Text(&#10;                                &quot;FINISH RUN&quot;,&#10;                                color = Color.White,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    // When not running, show only Start button&#10;                    Button(&#10;                        onClick = {&#10;                            val fineGranted = ContextCompat.checkSelfPermission(&#10;                                context,&#10;                                Manifest.permission.ACCESS_FINE_LOCATION&#10;                            ) == PackageManager.PERMISSION_GRANTED&#10;&#10;                            if (!fineGranted) {&#10;                                locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;                                return@Button&#10;                            }&#10;&#10;                            // START RUN&#10;                            println(&quot; Starting run via service...&quot;)&#10;&#10;                            if (!continueRun) {&#10;                                // Starting fresh run&#10;                                capturedAreaMeters2 = null&#10;&#10;                                // Start service and tracking&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.resetTracking()&#10;                                    locationService!!.startTracking()&#10;                                } else {&#10;                                    // Service not ready, start it directly&#10;                                    val intent = Intent(context, LocationTrackingService::class.java)&#10;                                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                                        context.startForegroundService(intent)&#10;                                    } else {&#10;                                        context.startService(intent)&#10;                                    }&#10;                                    context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;                                }&#10;                            } else {&#10;                                // Continuing existing run&#10;                                println(&quot;▶️ Resuming run with ${pathPoints.size} existing points&quot;)&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.continueTracking(pathPoints, distanceMeters)&#10;                                    locationService!!.startTracking()&#10;                                }&#10;                            }&#10;&#10;                            continueRun = false&#10;                        },&#10;                        modifier = Modifier&#10;                            .padding(vertical = 12.dp, horizontal = 24.dp)&#10;                            .fillMaxWidth()&#10;                            .height(56.dp),&#10;                        shape = RoundedCornerShape(28.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF2D3E6F)&#10;                        )&#10;                    ) {&#10;                        Text(&#10;                            &quot;START RUN&quot;,&#10;                            color = Color.White,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package tech.titans.runwars&#10;&#10;import android.Manifest&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.systemBars&#10;import androidx.compose.foundation.layout.windowInsetsPadding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.core.content.ContextCompat&#10;import androidx.navigation.NavController&#10;import com.google.android.gms.location.*&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.maps.android.compose.*&#10;import kotlinx.coroutines.launch&#10;import tech.titans.runwars.services.LocationTrackingService&#10;import tech.titans.runwars.services.UserService&#10;import tech.titans.runwars.utils.BatteryOptimizationHelper&#10;import tech.titans.runwars.utils.LocationUtils.calculateCapturedArea&#10;import tech.titans.runwars.utils.LocationUtils.createUserMarkerBitmap&#10;import tech.titans.runwars.utils.LocationUtils.isClosedLoop&#10;&#10;@Composable&#10;fun HomeScreen(navController: NavController) {&#10;    val userId = FirebaseAuth.getInstance().currentUser!!.uid&#10;    val context = LocalContext.current&#10;    val fusedLocationClient: FusedLocationProviderClient =&#10;        LocationServices.getFusedLocationProviderClient(context)&#10;&#10;    // Service binding&#10;    var locationService by remember { mutableStateOf&lt;LocationTrackingService?&gt;(null) }&#10;    var serviceBound by remember { mutableStateOf(false) }&#10;&#10;    // UI state from service&#10;    var currentLocation by remember { mutableStateOf(LatLng(46.7712, 23.6236)) }&#10;    var isRunning by remember { mutableStateOf(false) }&#10;    var isPaused by remember { mutableStateOf(false) }&#10;    var pathPoints by remember { mutableStateOf(listOf&lt;LatLng&gt;()) }&#10;    var pathSegments by remember { mutableStateOf(listOf&lt;List&lt;LatLng&gt;&gt;()) }&#10;    var distanceMeters by remember { mutableStateOf(0.0) }&#10;    var capturedAreaMeters2 by remember { mutableStateOf&lt;Double?&gt;(null) }&#10;    var showResultDialog by remember { mutableStateOf(false) }&#10;    var continueRun by remember { mutableStateOf(false) }&#10;&#10;    // Permission dialogs&#10;    var showBatteryOptimizationDialog by remember { mutableStateOf(false) }&#10;    var showBackgroundLocationDialog by remember { mutableStateOf(false) }&#10;&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = com.google.android.gms.maps.model.CameraPosition.fromLatLngZoom(currentLocation, 14f)&#10;    }&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Service connection&#10;    val serviceConnection = remember {&#10;        object : ServiceConnection {&#10;            override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {&#10;                val locationBinder = binder as? LocationTrackingService.LocationBinder&#10;                locationService = locationBinder?.getService()&#10;                serviceBound = true&#10;                println(&quot;✅ Service connected&quot;)&#10;            }&#10;&#10;            override fun onServiceDisconnected(name: ComponentName?) {&#10;                locationService = null&#10;                serviceBound = false&#10;                println(&quot;❌ Service disconnected&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Background location permission launcher (for Android 10+)&#10;    val backgroundLocationPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            if (granted) {&#10;                println(&quot;✅ Background location permission granted&quot;)&#10;                // Check battery optimization after background permission&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                    if (!BatteryOptimizationHelper.isBatteryOptimizationDisabled(context)) {&#10;                        showBatteryOptimizationDialog = true&#10;                    }&#10;                }&#10;            } else {&#10;                println(&quot;❌ Background location permission denied&quot;)&#10;            }&#10;        }&#10;    )&#10;&#10;    // Notification permission launcher (for Android 13+)&#10;    val notificationPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            if (granted) {&#10;                println(&quot;✅ Notification permission granted&quot;)&#10;            }&#10;        }&#10;    )&#10;&#10;    // Location permission launcher&#10;    val locationPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission(),&#10;        onResult = { granted -&gt;&#10;            if (granted) {&#10;                if (ContextCompat.checkSelfPermission(&#10;                        context,&#10;                        Manifest.permission.ACCESS_FINE_LOCATION&#10;                    ) == PackageManager.PERMISSION_GRANTED&#10;                ) {&#10;                    fusedLocationClient.lastLocation.addOnSuccessListener { location -&gt;&#10;                        location?.let {&#10;                            val newLocation = LatLng(it.latitude, it.longitude)&#10;                            currentLocation = newLocation&#10;                            cameraPositionState.position =&#10;                                com.google.android.gms.maps.model.CameraPosition.fromLatLngZoom(newLocation, 15f)&#10;                        }&#10;                    }&#10;&#10;                    // Request background location permission for Android 10+ (only if not already granted)&#10;                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                        val backgroundLocationGranted = ContextCompat.checkSelfPermission(&#10;                            context,&#10;                            Manifest.permission.ACCESS_BACKGROUND_LOCATION&#10;                        ) == PackageManager.PERMISSION_GRANTED&#10;&#10;                        if (!backgroundLocationGranted) {&#10;                            showBackgroundLocationDialog = true&#10;                        } else {&#10;                            // Background permission already granted, check battery optimization&#10;                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                                if (!BatteryOptimizationHelper.isBatteryOptimizationDisabled(context)) {&#10;                                    showBatteryOptimizationDialog = true&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    )&#10;&#10;    // Passive location request - for position updates when not running&#10;    val passiveLocationRequest = remember {&#10;        LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 10_000L)&#10;            .setMinUpdateIntervalMillis(5_000L)&#10;            .build()&#10;    }&#10;&#10;    // Location callback for passive position updates (when not running)&#10;    val passiveLocationCallback = remember {&#10;        object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                if (isRunning) return // Don't update if we're actively tracking&#10;&#10;                val loc = result.lastLocation ?: return&#10;                val newLocation = LatLng(loc.latitude, loc.longitude)&#10;                currentLocation = newLocation&#10;                println(&quot; Passive position updated: ${newLocation.latitude}, ${newLocation.longitude}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Sync state from service&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.isTracking.collect { tracking -&gt;&#10;                isRunning = tracking&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.isPaused.collect { paused -&gt;&#10;                isPaused = paused&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.pathPoints.collect { points -&gt;&#10;                pathPoints = points&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.pathSegments.collect { segments -&gt;&#10;                pathSegments = segments&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.distanceMeters.collect { distance -&gt;&#10;                distanceMeters = distance&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(serviceBound, locationService) {&#10;        if (serviceBound &amp;&amp; locationService != null) {&#10;            locationService!!.currentLocation.collect { location -&gt;&#10;                location?.let {&#10;                    currentLocation = it&#10;                    // Don't auto-center camera during run - let user control zoom/pan&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    val userMarkerState = rememberMarkerState(position = currentLocation)&#10;&#10;    // Update marker position when current location changes&#10;    LaunchedEffect(currentLocation) {&#10;        userMarkerState.position = currentLocation&#10;    }&#10;&#10;    // Background location permission dialog&#10;    if (showBackgroundLocationDialog &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;        AlertDialog(&#10;            onDismissRequest = { showBackgroundLocationDialog = false },&#10;            title = { Text(&quot;Background Location Permission&quot;) },&#10;            text = {&#10;                Text(&#10;                    &quot;To track your runs accurately even when the app is in the background or closed, &quot; +&#10;                    &quot;RunWars needs access to your location all the time.\n\n&quot; +&#10;                    &quot;Please select 'Allow all the time' on the next screen.&quot;&#10;                )&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showBackgroundLocationDialog = false&#10;                        backgroundLocationPermissionLauncher.launch(Manifest.permission.ACCESS_BACKGROUND_LOCATION)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Continue&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showBackgroundLocationDialog = false }) {&#10;                    Text(&quot;Skip&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Battery optimization dialog&#10;    if (showBatteryOptimizationDialog &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;        AlertDialog(&#10;            onDismissRequest = { showBatteryOptimizationDialog = false },&#10;            title = { Text(&quot;Disable Battery Optimization&quot;) },&#10;            text = {&#10;                Text(&#10;                    &quot;To ensure continuous GPS tracking during your runs, please disable &quot; +&#10;                    &quot;battery optimization for RunWars.\n\n&quot; +&#10;                    &quot;This prevents Android from stopping location updates to save battery.&quot;&#10;                )&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showBatteryOptimizationDialog = false&#10;                        BatteryOptimizationHelper.requestDisableBatteryOptimization(context)&#10;                    }&#10;                ) {&#10;                    Text(&quot;Open Settings&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showBatteryOptimizationDialog = false }) {&#10;                    Text(&quot;Skip&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Result dialog after run&#10;    LaunchedEffect(Unit) {&#10;        // Bind to location service&#10;        val intent = Intent(context, LocationTrackingService::class.java)&#10;        context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;&#10;        // Request permissions&#10;        locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;&#10;        // Request notification permission for Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;        }&#10;&#10;        // Start passive location updates for when not running&#10;        try {&#10;            if (ContextCompat.checkSelfPermission(&#10;                    context,&#10;                    Manifest.permission.ACCESS_FINE_LOCATION&#10;                ) == PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                fusedLocationClient.requestLocationUpdates(&#10;                    passiveLocationRequest,&#10;                    passiveLocationCallback,&#10;                    Looper.getMainLooper()&#10;                )&#10;                println(&quot;✅ Passive location updates started&quot;)&#10;            }&#10;        } catch (e: SecurityException) {&#10;            println(&quot;❌ Could not start passive location updates: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Cleanup location updates when leaving screen&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            fusedLocationClient.removeLocationUpdates(passiveLocationCallback)&#10;            context.unbindService(serviceConnection)&#10;            println(&quot;️ Service unbound&quot;)&#10;        }&#10;    }&#10;&#10;    // Result dialog after run&#10;    if (showResultDialog &amp;&amp; capturedAreaMeters2 != null) {&#10;        val isLoop = isClosedLoop(pathPoints)&#10;&#10;        AlertDialog(&#10;            onDismissRequest = {&#10;                showResultDialog = false&#10;                continueRun = true&#10;                // Resume tracking through service&#10;                if (serviceBound &amp;&amp; locationService != null) {&#10;                    locationService!!.continueTracking(pathPoints, distanceMeters)&#10;                    locationService!!.startTracking()&#10;                }&#10;            },&#10;            title = {&#10;                Text(&#10;                    if (isLoop) &quot;Territory Captured!&quot; else &quot;Run Completed&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;            },&#10;            text = {&#10;                Column {&#10;                    Text(&quot;Distance: %.2f km&quot;.format(distanceMeters / 1000))&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    if (isLoop &amp;&amp; capturedAreaMeters2!! &gt; 0) {&#10;                        Text(&quot;Territory: %.2f ha&quot;.format(&#10;                            capturedAreaMeters2!! / 10_000&#10;                        ))&#10;                    } else {&#10;                        Text(&#10;                            &quot;⚠️ You need to run in a loop to capture territory!&quot;,&#10;                            color = Color(0xFFFF9800),&#10;                            fontSize = 14.sp,&#10;                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                        )&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Text(&#10;                            &quot;Tip: End your run close to where you started (within 50m)&quot;,&#10;                            color = Color.Gray,&#10;                            fontSize = 12.sp&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ){&#10;                    if (isLoop &amp;&amp; capturedAreaMeters2!! &gt; 0) {&#10;                        Button(&#10;                            onClick = {&#10;                                showResultDialog = false&#10;                                UserService.addRunSessionToUser(distanceMeters, pathPoints, userId)&#10;                                // Reset service&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.resetTracking()&#10;                                }&#10;                                continueRun = false&#10;                            },&#10;                            colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF2D3E6F))&#10;                        ) {&#10;                            Text(&quot;Save Territory&quot;)&#10;                        }&#10;                        TextButton(onClick = {&#10;                            showResultDialog = false&#10;                            // Reset service&#10;                            if (serviceBound &amp;&amp; locationService != null) {&#10;                                locationService!!.resetTracking()&#10;                            }&#10;                            capturedAreaMeters2 = null&#10;                            continueRun = false&#10;                        }) {&#10;                            Text(&quot;Discard&quot;)&#10;                        }&#10;                    } else {&#10;                        if(pathPoints.size &gt;= 3) {&#10;                            Button(&#10;                                onClick = {&#10;                                    showResultDialog = false&#10;                                    UserService.addRunSessionToUser(distanceMeters, pathPoints, userId)&#10;                                    // Reset service&#10;                                    if (serviceBound &amp;&amp; locationService != null) {&#10;                                        locationService!!.resetTracking()&#10;                                    }&#10;                                    continueRun = false&#10;                                },&#10;                                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF2D3E6F))&#10;                            ) {&#10;                                Text(&quot;Save the run anyway&quot;)&#10;                            }&#10;                        }&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Button(&#10;                                onClick = {&#10;                                    showResultDialog = false&#10;                                    continueRun = true&#10;                                    // Resume tracking through service&#10;                                    if (serviceBound &amp;&amp; locationService != null) {&#10;                                        locationService!!.continueTracking(pathPoints, distanceMeters)&#10;                                        locationService!!.startTracking()&#10;                                    }&#10;                                },&#10;                                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF757575))&#10;                            ) {&#10;                                Text(&quot;Continue&quot;)&#10;                            }&#10;                            TextButton(onClick = {&#10;                                showResultDialog = false&#10;                                // Reset service&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.resetTracking()&#10;                                }&#10;                                capturedAreaMeters2 = null&#10;                                continueRun = false&#10;                            }) {&#10;                                Text(&quot;Discard&quot;)&#10;                            }&#10;                        }&#10;&#10;                    }&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        gesturesEnabled = drawerState.isOpen,&#10;        drawerContent = {&#10;            ModalDrawerSheet(&#10;                drawerContainerColor = Color(0xFF1E2A47),&#10;                modifier = Modifier.width(280.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxHeight()&#10;                ) {&#10;                    // Header&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;RunWars&quot;,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        color = Color.White,&#10;                        fontSize = 24.sp,&#10;                        style = MaterialTheme.typography.headlineMedium&#10;                    )&#10;                    HorizontalDivider(color = Color.White.copy(alpha = 0.2f))&#10;                    &#10;                    // Menu items&#10;                    listOf(&quot;Profile&quot;, &quot;Statistics&quot;, &quot;Leaderboard&quot;, &quot;Settings&quot;).forEach {&#10;                        NavigationDrawerItem(&#10;                            label = { Text(it, color = Color.White) },&#10;                            selected = false,&#10;                            onClick = {},&#10;                            modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp),&#10;                            colors = NavigationDrawerItemDefaults.colors(&#10;                                unselectedContainerColor = Color.Transparent,&#10;                                selectedContainerColor = Color(0xFF2D3E6F)&#10;                            )&#10;                        )&#10;                    }&#10;                    &#10;                    // Spacer to push logout to bottom&#10;                    Spacer(modifier = Modifier.weight(1f))&#10;                    &#10;                    HorizontalDivider(color = Color.White.copy(alpha = 0.2f))&#10;                    &#10;                    // Logout button&#10;                    NavigationDrawerItem(&#10;                        label = { &#10;                            Row(&#10;                                verticalAlignment = Alignment.CenterVertically,&#10;                                horizontalArrangement = Arrangement.Start&#10;                            ) {&#10;                                Icon(&#10;                                    painter = painterResource(id = android.R.drawable.ic_menu_close_clear_cancel),&#10;                                    contentDescription = &quot;Logout&quot;,&#10;                                    tint = Color(0xFFFF6B6B),&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                                Spacer(modifier = Modifier.width(12.dp))&#10;                                Text(&#10;                                    &quot;Logout&quot;, &#10;                                    color = Color(0xFFFF6B6B),&#10;                                    fontWeight = androidx.compose.ui.text.font.FontWeight.Medium&#10;                                )&#10;                            }&#10;                        },&#10;                        selected = false,&#10;                        onClick = {&#10;                            scope.launch {&#10;                                drawerState.close()&#10;                                &#10;                                // Clear &quot;stay logged in&quot; preference&#10;                                val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, android.content.Context.MODE_PRIVATE)&#10;                                prefs.edit().putBoolean(&quot;stayLoggedIn&quot;, false).apply()&#10;                                &#10;                                // Sign out from Firebase&#10;                                com.google.firebase.auth.FirebaseAuth.getInstance().signOut()&#10;                                &#10;                                // Navigate to login screen and clear back stack&#10;                                navController.navigate(&quot;login&quot;) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = true }&#10;                                }&#10;                            }&#10;                        },&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),&#10;                        colors = NavigationDrawerItemDefaults.colors(&#10;                            unselectedContainerColor = Color.Transparent,&#10;                            selectedContainerColor = Color(0xFF2D3E6F)&#10;                        )&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;            }&#10;        }&#10;    ) {&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;&#10;            // Google Map&#10;            GoogleMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                cameraPositionState = cameraPositionState,&#10;                uiSettings = MapUiSettings(zoomControlsEnabled = false)&#10;            ) {&#10;                // Custom user position marker&#10;                Marker(&#10;                    state = userMarkerState,&#10;                    title = if (isRunning) &quot;Running...&quot; else &quot;You&quot;,&#10;                    icon = BitmapDescriptorFactory.fromBitmap(createUserMarkerBitmap(isRunning)),&#10;                    anchor = Offset(0.5f, 0.5f),&#10;                    flat = true&#10;                )&#10;&#10;                // Running path (multiple polylines for segments)&#10;                // Each segment is drawn separately to show breaks when pause gap &gt; 50m&#10;                for (segment in pathSegments) {&#10;                    if (segment.size &gt;= 2) {&#10;                        Polyline(&#10;                            points = segment,&#10;                            color = if (isRunning) Color.Cyan else Color(0xFF2D3E6F),&#10;                            width = 8f&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Show captured territory when run is finished AND it forms a loop&#10;                if (!isRunning &amp;&amp; pathPoints.size &gt;= 3 &amp;&amp; isClosedLoop(pathPoints)) {&#10;                    val closedPath = if (pathPoints.first() != pathPoints.last()) {&#10;                        pathPoints + pathPoints.first()&#10;                    } else {&#10;                        pathPoints&#10;                    }&#10;&#10;                    Polygon(&#10;                        points = closedPath,&#10;                        fillColor = Color(0x552D3E6F),&#10;                        strokeColor = Color(0xFF2D3E6F),&#10;                        strokeWidth = 4f&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Dimming overlay when paused&#10;            if (isPaused) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.3f))&#10;                )&#10;            }&#10;&#10;            // Menu button (top right)&#10;            Surface(&#10;                onClick = {&#10;                    scope.launch {&#10;                        if (drawerState.isOpen) drawerState.close() else drawerState.open()&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .windowInsetsPadding(WindowInsets.systemBars)&#10;                    .padding(16.dp)&#10;                    .size(48.dp),&#10;                shape = androidx.compose.foundation.shape.CircleShape,&#10;                color = Color(0xFF1E2A47),&#10;                shadowElevation = 4.dp&#10;            ) {&#10;                Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Menu,&#10;                        contentDescription = &quot;Menu&quot;,&#10;                        tint = Color.White,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Distance display (top left)&#10;            if (isRunning || pathPoints.isNotEmpty()) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopStart)&#10;                        .windowInsetsPadding(WindowInsets.systemBars)&#10;                        .padding(16.dp)&#10;                        .background(Color(0xDD1E2A47), RoundedCornerShape(12.dp))&#10;                        .padding(horizontal = 16.dp, vertical = 12.dp)&#10;                ) {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        if (isRunning &amp;&amp; !isPaused) {&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .size(8.dp)&#10;                                    .background(Color.Green, androidx.compose.foundation.shape.CircleShape)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;                        Text(&#10;                            text = when {&#10;                                isPaused -&gt; &quot;PAUSED&quot;&#10;                                isRunning -&gt; &quot;RUNNING&quot;&#10;                                else -&gt; &quot;FINISHED&quot;&#10;                            },&#10;                            color = when {&#10;                                isPaused -&gt; Color(0xFFFF9800)&#10;                                isRunning -&gt; Color.Green&#10;                                else -&gt; Color.White&#10;                            },&#10;                            fontSize = 12.sp,&#10;                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                        )&#10;                    }&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Text(&#10;                        text = &quot;%.2f km&quot;.format(distanceMeters / 1000),&#10;                        color = Color.White,&#10;                        fontSize = 28.sp,&#10;                        fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                    )&#10;                    if (!isRunning &amp;&amp; capturedAreaMeters2 != null &amp;&amp; capturedAreaMeters2!! &gt; 0 &amp;&amp; isClosedLoop(pathPoints)) {&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Text(&#10;                            text = &quot;Territory: %.2f ha&quot;.format(capturedAreaMeters2!! / 10_000),&#10;                            color = Color.Cyan,&#10;                            fontSize = 16.sp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Recenter map FAB - show when running and (zoomed out OR user panned away)&#10;            // Calculate distance between camera center and user's actual location&#10;            val cameraCenterLat = cameraPositionState.position.target.latitude&#10;            val cameraCenterLng = cameraPositionState.position.target.longitude&#10;            val userLat = currentLocation.latitude&#10;            val userLng = currentLocation.longitude&#10;&#10;            // Calculate distance in meters using Haversine formula&#10;            val earthRadius = 6371000.0 // meters&#10;            val dLat = Math.toRadians(userLat - cameraCenterLat)&#10;            val dLng = Math.toRadians(userLng - cameraCenterLng)&#10;            val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;                    Math.cos(Math.toRadians(cameraCenterLat)) * Math.cos(Math.toRadians(userLat)) *&#10;                    Math.sin(dLng / 2) * Math.sin(dLng / 2)&#10;            val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))&#10;            val distanceFromCenter = earthRadius * c&#10;&#10;            // Show button if zoomed out (&lt; 15) OR if user is more than 100 meters away from their location&#10;            val shouldShowRecenterButton = isRunning &amp;&amp; (cameraPositionState.position.zoom &lt; 15f || distanceFromCenter &gt; 100)&#10;&#10;            if (shouldShowRecenterButton) {&#10;                FloatingActionButton(&#10;                    onClick = {&#10;                        scope.launch {&#10;                            cameraPositionState.animate(&#10;                                com.google.android.gms.maps.CameraUpdateFactory.newLatLngZoom(&#10;                                    currentLocation,&#10;                                    16f&#10;                                ),&#10;                                durationMs = 500&#10;                            )&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomEnd)&#10;                        .windowInsetsPadding(WindowInsets.navigationBars)&#10;                        .padding(end = 16.dp, bottom = 100.dp),&#10;                    containerColor = Color(0xFF1E2A47),&#10;                    contentColor = Color.White,&#10;                    elevation = FloatingActionButtonDefaults.elevation(&#10;                        defaultElevation = 6.dp,&#10;                        pressedElevation = 12.dp&#10;                    )&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.LocationOn,&#10;                        contentDescription = &quot;Recenter Map&quot;,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Start/Finish button (bottom)&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.BottomCenter)&#10;                    .background(Color(0xEE1E2A47))&#10;                    .windowInsetsPadding(WindowInsets.navigationBars)&#10;            ) {&#10;                if (isRunning) {&#10;                    // When running, show two buttons: Pause/Resume and Finish&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 24.dp, vertical = 12.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        // Pause/Resume button&#10;                        Button(&#10;                            onClick = {&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    if (isPaused) {&#10;                                        println(&quot;▶️ Resuming run...&quot;)&#10;                                        locationService!!.resumeTracking()&#10;                                    } else {&#10;                                        println(&quot;⏸️ Pausing run...&quot;)&#10;                                        locationService!!.pauseTracking()&#10;                                    }&#10;                                }&#10;                            },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .height(56.dp),&#10;                            shape = RoundedCornerShape(28.dp),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = if (isPaused) Color(0xFF4CAF50) else Color(0xFFFF9800)&#10;                            )&#10;                        ) {&#10;                            Text(&#10;                                if (isPaused) &quot;RESUME&quot; else &quot;PAUSE&quot;,&#10;                                color = Color.White,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                            )&#10;                        }&#10;&#10;                        // Finish button&#10;                        Button(&#10;                            onClick = {&#10;                                println(&quot; Finishing run via service...&quot;)&#10;&#10;                                // Stop service tracking&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.stopTracking()&#10;                                }&#10;&#10;                                // Calculate captured territory only if it's a closed loop&#10;                                capturedAreaMeters2 =&#10;                                    if (pathPoints.size &gt;= 3 &amp;&amp; isClosedLoop(pathPoints)) {&#10;                                        calculateCapturedArea(pathPoints)&#10;                                    } else {&#10;                                        0.0&#10;                                    }&#10;&#10;                                // Show result dialog&#10;                                showResultDialog = true&#10;                            },&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .height(56.dp),&#10;                            shape = RoundedCornerShape(28.dp),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = Color(0xFFD32F2F)&#10;                            )&#10;                        ) {&#10;                            Text(&#10;                                &quot;FINISH RUN&quot;,&#10;                                color = Color.White,&#10;                                fontSize = 18.sp,&#10;                                fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    // When not running, show only Start button&#10;                    Button(&#10;                        onClick = {&#10;                            val fineGranted = ContextCompat.checkSelfPermission(&#10;                                context,&#10;                                Manifest.permission.ACCESS_FINE_LOCATION&#10;                            ) == PackageManager.PERMISSION_GRANTED&#10;&#10;                            if (!fineGranted) {&#10;                                locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;                                return@Button&#10;                            }&#10;&#10;                            // START RUN&#10;                            println(&quot; Starting run via service...&quot;)&#10;&#10;                            if (!continueRun) {&#10;                                // Starting fresh run&#10;                                capturedAreaMeters2 = null&#10;&#10;                                // Start service and tracking&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.resetTracking()&#10;                                    locationService!!.startTracking()&#10;                                } else {&#10;                                    // Service not ready, start it directly&#10;                                    val intent = Intent(context, LocationTrackingService::class.java)&#10;                                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                                        context.startForegroundService(intent)&#10;                                    } else {&#10;                                        context.startService(intent)&#10;                                    }&#10;                                    context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;                                }&#10;                            } else {&#10;                                // Continuing existing run&#10;                                println(&quot;▶️ Resuming run with ${pathPoints.size} existing points&quot;)&#10;                                if (serviceBound &amp;&amp; locationService != null) {&#10;                                    locationService!!.continueTracking(pathPoints, distanceMeters)&#10;                                    locationService!!.startTracking()&#10;                                }&#10;                            }&#10;&#10;                            continueRun = false&#10;                        },&#10;                        modifier = Modifier&#10;                            .padding(vertical = 12.dp, horizontal = 24.dp)&#10;                            .fillMaxWidth()&#10;                            .height(56.dp),&#10;                        shape = RoundedCornerShape(28.dp),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF2D3E6F)&#10;                        )&#10;                    ) {&#10;                        Text(&#10;                            &quot;START RUN&quot;,&#10;                            color = Color.White,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/LoginScreen.kt" />
              <option name="originalContent" value="package tech.titans.runwars&#10;import android.content.Context&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import tech.titans.runwars.views.LoginViewModel&#10;&#10;@Composable&#10;fun LoginScreen(navController: androidx.navigation.NavController, viewModel: LoginViewModel = viewModel()) {&#10;&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, Context.MODE_PRIVATE)&#10;    &#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var stayLoggedIn by remember { mutableStateOf(prefs.getBoolean(&quot;stayLoggedIn&quot;, true)) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    // Extract login logic into a function for reuse&#10;    val performLogin: () -&gt; Unit = {&#10;        if(email.isEmpty() || password.isEmpty()){&#10;            errorMessage = &quot;All fields are required&quot;&#10;        } else {&#10;            errorMessage = null&#10;            isLoading = true&#10;            viewModel.login(email, password, { success, error -&gt;&#10;                isLoading = false&#10;                if(success){&#10;                    // Save &quot;stay logged in&quot; preference&#10;                    prefs.edit().putBoolean(&quot;stayLoggedIn&quot;, stayLoggedIn).apply()&#10;                    navController.navigate(&quot;home&quot;)&#10;                }&#10;                else{&#10;                    errorMessage = error ?: &quot;Login failed&quot;&#10;                }&#10;            })&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0xFF2C1E3C))&#10;            .windowInsetsPadding(WindowInsets.systemBars)&#10;            .padding(24.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;&#10;            // Titlul aplicației&#10;            Text(&#10;                text = &quot;RunWars&quot;,&#10;                fontSize = 40.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                modifier = Modifier.padding(bottom = 50.dp)&#10;            )&#10;&#10;            // Câmp Email&#10;            OutlinedTextField(&#10;                value = email,&#10;                onValueChange = { email = it },&#10;                label = { Text(&quot;Email&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Email,&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 20.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Password&#10;            OutlinedTextField(&#10;                value = password,&#10;                onValueChange = { password = it },&#10;                label = { Text(&quot;Password&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                visualTransformation = PasswordVisualTransformation(),&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Password,&#10;                    imeAction = ImeAction.Done&#10;                ),&#10;                keyboardActions = KeyboardActions(&#10;                    onDone = { performLogin() }&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 20.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Stay Logged In Checkbox&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 30.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Checkbox(&#10;                    checked = stayLoggedIn,&#10;                    onCheckedChange = { stayLoggedIn = it },&#10;                    enabled = !isLoading,&#10;                    colors = CheckboxDefaults.colors(&#10;                        checkedColor = Color(0xFF8E5DFF),&#10;                        uncheckedColor = Color(0xFF8E5DFF),&#10;                        checkmarkColor = Color.White,&#10;                        disabledCheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                        disabledUncheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f)&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;Stay logged in&quot;,&#10;                    color = if (isLoading) Color.White.copy(alpha = 0.5f) else Color.White,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;&#10;            // Buton Login&#10;            Button(&#10;                onClick = performLogin,&#10;                enabled = !isLoading,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(55.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = Color.Black,&#10;                    contentColor = Color.White,&#10;                    disabledContainerColor = Color.Black.copy(alpha = 0.5f),&#10;                    disabledContentColor = Color.White.copy(alpha = 0.5f)&#10;                ),&#10;                shape = MaterialTheme.shapes.medium&#10;&#10;            ) {&#10;                if (isLoading) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(24.dp),&#10;                        color = Color.White,&#10;                        strokeWidth = 2.dp&#10;                    )&#10;                } else {&#10;                    Text(&#10;                        text = &quot;Login&quot;,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                }&#10;            }&#10;            if(!errorMessage.isNullOrEmpty()){&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(text = errorMessage ?: &quot;&quot;, color = Color.Red)&#10;            }&#10;&#10;            // Text de trecere la Register&#10;            TextButton(&#10;                onClick = { navController.navigate(&quot;register&quot;) },&#10;                enabled = !isLoading,&#10;                modifier = Modifier.padding(top = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Don't have an account? Register&quot;,&#10;                    color = if (isLoading) Color(0xFF8E5DFF).copy(alpha = 0.5f) else Color(0xFF8E5DFF),&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tech.titans.runwars&#10;import android.content.Context&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import tech.titans.runwars.views.LoginViewModel&#10;&#10;@Composable&#10;fun LoginScreen(navController: androidx.navigation.NavController, viewModel: LoginViewModel = viewModel()) {&#10;&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, Context.MODE_PRIVATE)&#10;    &#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var stayLoggedIn by remember { mutableStateOf(prefs.getBoolean(&quot;stayLoggedIn&quot;, true)) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    // Extract login logic into a function for reuse&#10;    val performLogin: () -&gt; Unit = {&#10;        if(email.isEmpty() || password.isEmpty()){&#10;            errorMessage = &quot;All fields are required&quot;&#10;        } else {&#10;            errorMessage = null&#10;            isLoading = true&#10;            viewModel.login(email, password, { success, error -&gt;&#10;                isLoading = false&#10;                if(success){&#10;                    // Save &quot;stay logged in&quot; preference&#10;                    prefs.edit().putBoolean(&quot;stayLoggedIn&quot;, stayLoggedIn).apply()&#10;                    navController.navigate(&quot;home&quot;)&#10;                }&#10;                else{&#10;                    errorMessage = error ?: &quot;Login failed&quot;&#10;                }&#10;            })&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0xFF2C1E3C))&#10;            .windowInsetsPadding(WindowInsets.systemBars)&#10;            .padding(24.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;&#10;            // Titlul aplicației&#10;            Text(&#10;                text = &quot;RunWars&quot;,&#10;                fontSize = 40.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                modifier = Modifier.padding(bottom = 50.dp)&#10;            )&#10;&#10;            // Câmp Email&#10;            OutlinedTextField(&#10;                value = email,&#10;                onValueChange = { email = it },&#10;                label = { Text(&quot;Email&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Email,&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 20.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Password&#10;            OutlinedTextField(&#10;                value = password,&#10;                onValueChange = { password = it },&#10;                label = { Text(&quot;Password&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                visualTransformation = PasswordVisualTransformation(),&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Password,&#10;                    imeAction = ImeAction.Done&#10;                ),&#10;                keyboardActions = KeyboardActions(&#10;                    onDone = { performLogin() }&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 20.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Stay Logged In Checkbox&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 30.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Checkbox(&#10;                    checked = stayLoggedIn,&#10;                    onCheckedChange = { stayLoggedIn = it },&#10;                    enabled = !isLoading,&#10;                    colors = CheckboxDefaults.colors(&#10;                        checkedColor = Color(0xFF8E5DFF),&#10;                        uncheckedColor = Color(0xFF8E5DFF),&#10;                        checkmarkColor = Color.White,&#10;                        disabledCheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                        disabledUncheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f)&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;Stay logged in&quot;,&#10;                    color = if (isLoading) Color.White.copy(alpha = 0.5f) else Color.White,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;&#10;            // Buton Login&#10;            Button(&#10;                onClick = performLogin,&#10;                enabled = !isLoading,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(55.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = Color.Black,&#10;                    contentColor = Color.White,&#10;                    disabledContainerColor = Color.Black.copy(alpha = 0.5f),&#10;                    disabledContentColor = Color.White.copy(alpha = 0.5f)&#10;                ),&#10;                shape = MaterialTheme.shapes.medium&#10;&#10;            ) {&#10;                if (isLoading) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(24.dp),&#10;                        color = Color.White,&#10;                        strokeWidth = 2.dp&#10;                    )&#10;                } else {&#10;                    Text(&#10;                        text = &quot;Login&quot;,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                }&#10;            }&#10;            if(!errorMessage.isNullOrEmpty()){&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(text = errorMessage ?: &quot;&quot;, color = Color.Red)&#10;            }&#10;&#10;            // Text de trecere la Register&#10;            TextButton(&#10;                onClick = { navController.navigate(&quot;register&quot;) },&#10;                enabled = !isLoading,&#10;                modifier = Modifier.padding(top = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Don't have an account? Register&quot;,&#10;                    color = if (isLoading) Color(0xFF8E5DFF).copy(alpha = 0.5f) else Color(0xFF8E5DFF),&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/MainActivity.kt" />
              <option name="originalContent" value="package tech.titans.runwars&#10;&#10;import android.content.Context&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.view.WindowCompat&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.google.firebase.auth.FirebaseAuth&#10;import tech.titans.runwars.ui.theme.RunWarsTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;  /*  override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            RunWarsTheme {&#10;                Scaffold(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    bottomBar = {&#10;                        BottomAppBar(modifier = Modifier.height(80.dp),&#10;                            containerColor = Color(0xFF272244)&#10;                        )&#10;                        {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                contentAlignment = Alignment.Center&#10;                                )&#10;                                {&#10;                                    RunButton()&#10;                                }&#10;                        }&#10;                    }&#10;                    )&#10;                { innerPadding -&gt;&#10;                    Greeting(&#10;                        name = &quot;Android&quot;,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    )&#10;                    MapImage()&#10;                    PersonIcon()&#10;                    MenuButton()&#10;                }&#10;            }&#10;        }&#10;    }*/&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Disable edge-to-edge to prevent transparent system bars on Android 14+&#10;        WindowCompat.setDecorFitsSystemWindows(window, true)&#10;&#10;        setContent {&#10;            RunWarsTheme {&#10;                Navigation()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Navigation(){&#10;    val navController = rememberNavController()&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, Context.MODE_PRIVATE)&#10;    val stayLoggedIn = prefs.getBoolean(&quot;stayLoggedIn&quot;, false)&#10;    val currentUser = FirebaseAuth.getInstance().currentUser&#10;    &#10;    // Determine start destination based on auth state&#10;    val startDestination = if (currentUser != null &amp;&amp; stayLoggedIn) {&#10;        &quot;home&quot;&#10;    } else {&#10;        if (currentUser != null &amp;&amp; !stayLoggedIn) {&#10;            // User is logged in but didn't check &quot;stay logged in&quot;, so log them out&#10;            FirebaseAuth.getInstance().signOut()&#10;        }&#10;        &quot;login&quot;&#10;    }&#10;&#10;    NavHost(navController = navController, startDestination = startDestination){&#10;        composable(&quot;login&quot;) { LoginScreen(navController) }&#10;        composable(&quot;register&quot;) { RegisterScreen(navController) }&#10;        composable(&quot;home&quot;) { HomeScreen(navController) }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MapImage(){&#10;    Image(&#10;        painter = painterResource(id = R.drawable.map),&#10;        contentDescription = &quot;Map&quot;,&#10;        contentScale = ContentScale.Crop,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;    )&#10;}&#10;&#10;@Composable&#10;fun MenuButton(){&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(top = 15.dp),&#10;        verticalArrangement = Arrangement.Top,&#10;        horizontalAlignment = Alignment.End&#10;    )&#10;    {&#10;        Button(onClick = {print(&quot;Clicked&quot;)}){&#10;            Image(&#10;                painter = painterResource(id = R.drawable.outline_dehaze_24),&#10;                contentDescription = &quot;Menu Button&quot;&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PersonIcon(){&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize(),&#10;        verticalArrangement = Arrangement.Center,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Image(&#10;            painter = painterResource(id = R.drawable.baseline_circle_24),&#10;            contentDescription = &quot;Person Icon&quot;,&#10;            colorFilter = ColorFilter.tint(Color.Blue)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RunButton(){&#10;    Button(onClick = {print(&quot;Clicked&quot;)}){&#10;        Text(&quot;Start Run&quot;)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Greeting(name: String, modifier: Modifier = Modifier) {&#10;    Text(&#10;        text = &quot;Hello $name!&quot;,&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GreetingPreview() {&#10;    RunWarsTheme {&#10;        Greeting(&quot;Android&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package tech.titans.runwars&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.os.Bundle&#13;&#10;import androidx.activity.ComponentActivity&#13;&#10;import androidx.activity.compose.setContent&#13;&#10;import androidx.compose.foundation.Image&#13;&#10;import androidx.compose.foundation.layout.Arrangement&#13;&#10;import androidx.compose.foundation.layout.Column&#13;&#10;import androidx.compose.foundation.layout.fillMaxSize&#13;&#10;import androidx.compose.foundation.layout.padding&#13;&#10;import androidx.compose.material3.Button&#13;&#10;import androidx.compose.material3.Text&#13;&#10;import androidx.compose.runtime.Composable&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.graphics.ColorFilter&#13;&#10;import androidx.compose.ui.layout.ContentScale&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.compose.ui.res.painterResource&#13;&#10;import androidx.compose.ui.tooling.preview.Preview&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.core.view.WindowCompat&#13;&#10;import androidx.navigation.compose.NavHost&#13;&#10;import androidx.navigation.compose.composable&#13;&#10;import androidx.navigation.compose.rememberNavController&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import tech.titans.runwars.ui.theme.RunWarsTheme&#13;&#10;&#13;&#10;class MainActivity : ComponentActivity() {&#13;&#10;  /*  override fun onCreate(savedInstanceState: Bundle?) {&#13;&#10;        super.onCreate(savedInstanceState)&#13;&#10;        enableEdgeToEdge()&#13;&#10;        setContent {&#13;&#10;            RunWarsTheme {&#13;&#10;                Scaffold(&#13;&#10;                    modifier = Modifier.fillMaxSize(),&#13;&#10;                    bottomBar = {&#13;&#10;                        BottomAppBar(modifier = Modifier.height(80.dp),&#13;&#10;                            containerColor = Color(0xFF272244)&#13;&#10;                        )&#13;&#10;                        {&#13;&#10;                            Box(&#13;&#10;                                modifier = Modifier.fillMaxWidth(),&#13;&#10;                                contentAlignment = Alignment.Center&#13;&#10;                                )&#13;&#10;                                {&#13;&#10;                                    RunButton()&#13;&#10;                                }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    )&#13;&#10;                { innerPadding -&gt;&#13;&#10;                    Greeting(&#13;&#10;                        name = &quot;Android&quot;,&#13;&#10;                        modifier = Modifier.padding(innerPadding)&#13;&#10;                    )&#13;&#10;                    MapImage()&#13;&#10;                    PersonIcon()&#13;&#10;                    MenuButton()&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }*/&#13;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#13;&#10;        super.onCreate(savedInstanceState)&#13;&#10;&#13;&#10;        // Disable edge-to-edge to prevent transparent system bars on Android 14+&#13;&#10;        WindowCompat.setDecorFitsSystemWindows(window, true)&#13;&#10;&#13;&#10;        setContent {&#13;&#10;            RunWarsTheme {&#13;&#10;                Navigation()&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun Navigation(){&#13;&#10;    val navController = rememberNavController()&#13;&#10;    val context = LocalContext.current&#13;&#10;    val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, Context.MODE_PRIVATE)&#13;&#10;    val stayLoggedIn = prefs.getBoolean(&quot;stayLoggedIn&quot;, false)&#13;&#10;    val currentUser = FirebaseAuth.getInstance().currentUser&#13;&#10;    &#13;&#10;    // Determine start destination based on auth state&#13;&#10;    val startDestination = if (currentUser != null &amp;&amp; stayLoggedIn) {&#13;&#10;        &quot;home&quot;&#13;&#10;    } else {&#13;&#10;        if (currentUser != null &amp;&amp; !stayLoggedIn) {&#13;&#10;            // User is logged in but didn't check &quot;stay logged in&quot;, so log them out&#13;&#10;            FirebaseAuth.getInstance().signOut()&#13;&#10;        }&#13;&#10;        &quot;login&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    NavHost(navController = navController, startDestination = startDestination){&#13;&#10;        composable(&quot;login&quot;) { LoginScreen(navController) }&#13;&#10;        composable(&quot;register&quot;) { RegisterScreen(navController) }&#13;&#10;        composable(&quot;home&quot;) { HomeScreen(navController) }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Preview(showBackground = true)&#13;&#10;@Composable&#13;&#10;fun MapImage(){&#13;&#10;    Image(&#13;&#10;        painter = painterResource(id = R.drawable.map),&#13;&#10;        contentDescription = &quot;Map&quot;,&#13;&#10;        contentScale = ContentScale.Crop,&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;    )&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun MenuButton(){&#13;&#10;    Column(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;            .padding(top = 15.dp),&#13;&#10;        verticalArrangement = Arrangement.Top,&#13;&#10;        horizontalAlignment = Alignment.End&#13;&#10;    )&#13;&#10;    {&#13;&#10;        Button(onClick = {print(&quot;Clicked&quot;)}){&#13;&#10;            Image(&#13;&#10;                painter = painterResource(id = R.drawable.outline_dehaze_24),&#13;&#10;                contentDescription = &quot;Menu Button&quot;&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun PersonIcon(){&#13;&#10;    Column(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize(),&#13;&#10;        verticalArrangement = Arrangement.Center,&#13;&#10;        horizontalAlignment = Alignment.CenterHorizontally&#13;&#10;    ) {&#13;&#10;        Image(&#13;&#10;            painter = painterResource(id = R.drawable.baseline_circle_24),&#13;&#10;            contentDescription = &quot;Person Icon&quot;,&#13;&#10;            colorFilter = ColorFilter.tint(Color.Blue)&#13;&#10;        )&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun RunButton(){&#13;&#10;    Button(onClick = {print(&quot;Clicked&quot;)}){&#13;&#10;        Text(&quot;Start Run&quot;)&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun Greeting(name: String, modifier: Modifier = Modifier) {&#13;&#10;    Text(&#13;&#10;        text = &quot;Hello $name!&quot;,&#13;&#10;        modifier = modifier&#13;&#10;    )&#13;&#10;}&#13;&#10;&#13;&#10;@Preview(showBackground = true)&#13;&#10;@Composable&#13;&#10;fun GreetingPreview() {&#13;&#10;    RunWarsTheme {&#13;&#10;        Greeting(&quot;Android&quot;)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/RegisterScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/RegisterScreen.kt" />
              <option name="originalContent" value="package tech.titans.runwars&#10;&#10;import android.content.Context&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import tech.titans.runwars.views.SignUpViewModel&#10;&#10;@Composable&#10;fun RegisterScreen(navController: androidx.navigation.NavController,&#10;                   viewModel: SignUpViewModel = viewModel()) {&#10;&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    var firstName by remember { mutableStateOf(&quot;&quot;) }&#10;    var lastName by remember { mutableStateOf(&quot;&quot;) }&#10;    var userName by remember { mutableStateOf(&quot;&quot;) }&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var stayLoggedIn by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    // Extract register logic into a function for reuse&#10;    val performRegister: () -&gt; Unit = {&#10;        if(firstName.isEmpty() || lastName.isEmpty() || userName.isEmpty() || email.isEmpty() || password.isEmpty()){&#10;            errorMessage = &quot;All fields are required&quot;&#10;        } else {&#10;            errorMessage = null&#10;            isLoading = true&#10;            viewModel.signUp(firstName, lastName, userName, email, password, { success, error -&gt;&#10;                isLoading = false&#10;                if(success){&#10;                    // Save &quot;stay logged in&quot; preference&#10;                    prefs.edit().putBoolean(&quot;stayLoggedIn&quot;, stayLoggedIn).apply()&#10;                    navController.navigate(&quot;home&quot;)&#10;                }&#10;                else{&#10;                    errorMessage = error ?: &quot;Sign Up failed&quot;&#10;                }&#10;            })&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0xFF2C1E3C))&#10;            .windowInsetsPadding(WindowInsets.systemBars)&#10;            .padding(24.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;&#10;            // Titlul aplicației&#10;            Text(&#10;                text = &quot;Register&quot;,&#10;                fontSize = 40.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                modifier = Modifier.padding(bottom = 40.dp)&#10;            )&#10;&#10;            // Câmp First Name&#10;            OutlinedTextField(&#10;                value = firstName,&#10;                onValueChange = { firstName = it },&#10;                label = { Text(&quot;First Name&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Last Name&#10;            OutlinedTextField(&#10;                value = lastName,&#10;                onValueChange = { lastName = it },&#10;                label = { Text(&quot;Last Name&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp User Name&#10;            OutlinedTextField(&#10;                value = userName,&#10;                onValueChange = { userName = it },&#10;                label = { Text(&quot;User Name&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Email&#10;            OutlinedTextField(&#10;                value = email,&#10;                onValueChange = { email = it },&#10;                label = { Text(&quot;Email&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Email,&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Password&#10;            OutlinedTextField(&#10;                value = password,&#10;                onValueChange = { password = it },&#10;                label = { Text(&quot;Password&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                visualTransformation = PasswordVisualTransformation(),&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Password,&#10;                    imeAction = ImeAction.Done&#10;                ),&#10;                keyboardActions = KeyboardActions(&#10;                    onDone = { performRegister() }&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 20.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Stay Logged In Checkbox&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 30.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Checkbox(&#10;                    checked = stayLoggedIn,&#10;                    onCheckedChange = { stayLoggedIn = it },&#10;                    enabled = !isLoading,&#10;                    colors = CheckboxDefaults.colors(&#10;                        checkedColor = Color(0xFF8E5DFF),&#10;                        uncheckedColor = Color(0xFF8E5DFF),&#10;                        checkmarkColor = Color.White,&#10;                        disabledCheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                        disabledUncheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f)&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;Stay logged in&quot;,&#10;                    color = if (isLoading) Color.White.copy(alpha = 0.5f) else Color.White,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;&#10;            // Buton Register&#10;            Button(&#10;                onClick = performRegister,&#10;                enabled = !isLoading,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(55.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = Color.Black,&#10;                    contentColor = Color.White,&#10;                    disabledContainerColor = Color.Black.copy(alpha = 0.5f),&#10;                    disabledContentColor = Color.White.copy(alpha = 0.5f)&#10;                ),&#10;                shape = MaterialTheme.shapes.medium&#10;            ) {&#10;                if (isLoading) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(24.dp),&#10;                        color = Color.White,&#10;                        strokeWidth = 2.dp&#10;                    )&#10;                } else {&#10;                    Text(&#10;                        text = &quot;Register&quot;,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                }&#10;            }&#10;            if(!errorMessage.isNullOrEmpty()){&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(text = errorMessage ?: &quot;&quot;, color = Color.Red)&#10;            }&#10;&#10;            // Text de revenire la Login&#10;            TextButton(&#10;                onClick = { navController.popBackStack() },&#10;                enabled = !isLoading,&#10;                modifier = Modifier.padding(top = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Already have an account? Login&quot;,&#10;                    color = if (isLoading) Color(0xFF8E5DFF).copy(alpha = 0.5f) else Color(0xFF8E5DFF),&#10;                    fontSize = 14.sp,&#10;                    softWrap = true&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tech.titans.runwars&#10;&#10;import android.content.Context&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import tech.titans.runwars.views.SignUpViewModel&#10;&#10;@Composable&#10;fun RegisterScreen(navController: androidx.navigation.NavController,&#10;                   viewModel: SignUpViewModel = viewModel()) {&#10;&#10;    val context = LocalContext.current&#10;    val prefs = context.getSharedPreferences(&quot;RunWarsPrefs&quot;, Context.MODE_PRIVATE)&#10;&#10;    var firstName by remember { mutableStateOf(&quot;&quot;) }&#10;    var lastName by remember { mutableStateOf(&quot;&quot;) }&#10;    var userName by remember { mutableStateOf(&quot;&quot;) }&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var stayLoggedIn by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    // Extract register logic into a function for reuse&#10;    val performRegister: () -&gt; Unit = {&#10;        if(firstName.isEmpty() || lastName.isEmpty() || userName.isEmpty() || email.isEmpty() || password.isEmpty()){&#10;            errorMessage = &quot;All fields are required&quot;&#10;        } else {&#10;            errorMessage = null&#10;            isLoading = true&#10;            viewModel.signUp(firstName, lastName, userName, email, password, { success, error -&gt;&#10;                isLoading = false&#10;                if(success){&#10;                    // Save &quot;stay logged in&quot; preference&#10;                    prefs.edit().putBoolean(&quot;stayLoggedIn&quot;, stayLoggedIn).apply()&#10;                    navController.navigate(&quot;home&quot;)&#10;                }&#10;                else{&#10;                    errorMessage = error ?: &quot;Sign Up failed&quot;&#10;                }&#10;            })&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color(0xFF2C1E3C))&#10;            .windowInsetsPadding(WindowInsets.systemBars)&#10;            .padding(24.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;&#10;            // Titlul aplicației&#10;            Text(&#10;                text = &quot;Register&quot;,&#10;                fontSize = 40.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                modifier = Modifier.padding(bottom = 40.dp)&#10;            )&#10;&#10;            // Câmp First Name&#10;            OutlinedTextField(&#10;                value = firstName,&#10;                onValueChange = { firstName = it },&#10;                label = { Text(&quot;First Name&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Last Name&#10;            OutlinedTextField(&#10;                value = lastName,&#10;                onValueChange = { lastName = it },&#10;                label = { Text(&quot;Last Name&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp User Name&#10;            OutlinedTextField(&#10;                value = userName,&#10;                onValueChange = { userName = it },&#10;                label = { Text(&quot;User Name&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Email&#10;            OutlinedTextField(&#10;                value = email,&#10;                onValueChange = { email = it },&#10;                label = { Text(&quot;Email&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Email,&#10;                    imeAction = ImeAction.Next&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Câmp Password&#10;            OutlinedTextField(&#10;                value = password,&#10;                onValueChange = { password = it },&#10;                label = { Text(&quot;Password&quot;, color = Color(0xFFAAAAAA)) },&#10;                singleLine = true,&#10;                enabled = !isLoading,&#10;                visualTransformation = PasswordVisualTransformation(),&#10;                keyboardOptions = KeyboardOptions(&#10;                    keyboardType = KeyboardType.Password,&#10;                    imeAction = ImeAction.Done&#10;                ),&#10;                keyboardActions = KeyboardActions(&#10;                    onDone = { performRegister() }&#10;                ),&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 20.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFF8E5DFF),&#10;                    unfocusedBorderColor = Color(0xFF8E5DFF),&#10;                    cursorColor = Color.White,&#10;                    focusedLabelColor = Color(0xFF8E5DFF),&#10;                    unfocusedLabelColor = Color(0xFFAAAAAA),&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    disabledBorderColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                    disabledLabelColor = Color(0xFFAAAAAA).copy(alpha = 0.5f),&#10;                    disabledTextColor = Color.White.copy(alpha = 0.5f)&#10;                )&#10;            )&#10;&#10;            // Stay Logged In Checkbox&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 30.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Checkbox(&#10;                    checked = stayLoggedIn,&#10;                    onCheckedChange = { stayLoggedIn = it },&#10;                    enabled = !isLoading,&#10;                    colors = CheckboxDefaults.colors(&#10;                        checkedColor = Color(0xFF8E5DFF),&#10;                        uncheckedColor = Color(0xFF8E5DFF),&#10;                        checkmarkColor = Color.White,&#10;                        disabledCheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f),&#10;                        disabledUncheckedColor = Color(0xFF8E5DFF).copy(alpha = 0.5f)&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;Stay logged in&quot;,&#10;                    color = if (isLoading) Color.White.copy(alpha = 0.5f) else Color.White,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;&#10;            // Buton Register&#10;            Button(&#10;                onClick = performRegister,&#10;                enabled = !isLoading,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(55.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = Color.Black,&#10;                    contentColor = Color.White,&#10;                    disabledContainerColor = Color.Black.copy(alpha = 0.5f),&#10;                    disabledContentColor = Color.White.copy(alpha = 0.5f)&#10;                ),&#10;                shape = MaterialTheme.shapes.medium&#10;            ) {&#10;                if (isLoading) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(24.dp),&#10;                        color = Color.White,&#10;                        strokeWidth = 2.dp&#10;                    )&#10;                } else {&#10;                    Text(&#10;                        text = &quot;Register&quot;,&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                }&#10;            }&#10;            if(!errorMessage.isNullOrEmpty()){&#10;                Spacer(Modifier.height(8.dp))&#10;                Text(text = errorMessage ?: &quot;&quot;, color = Color.Red)&#10;            }&#10;&#10;            // Text de revenire la Login&#10;            TextButton(&#10;                onClick = { navController.popBackStack() },&#10;                enabled = !isLoading,&#10;                modifier = Modifier.padding(top = 16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Already have an account? Login&quot;,&#10;                    color = if (isLoading) Color(0xFF8E5DFF).copy(alpha = 0.5f) else Color(0xFF8E5DFF),&#10;                    fontSize = 14.sp,&#10;                    softWrap = true&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/utils/KalmanLatLong.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tech/titans/runwars/utils/KalmanLatLong.kt" />
              <option name="originalContent" value="package tech.titans.runwars.utils&#10;&#10;&#10;/**&#10; * Kalman Filter implementation for GPS coordinates (latitude/longitude).&#10; * Uses a 2D state vector [lat, lng] with velocity estimation.&#10; */&#10;class KalmanLatLong(&#10;    private var processNoise: Float = 0.5f // Q - process noise covariance&#10;) {&#10;    // State vector: [latitude, longitude]&#10;    private var latitude: Double = 0.0&#10;    private var longitude: Double = 0.0&#10;&#10;    // Velocity estimates (degrees per second)&#10;    private var velocityLat: Double = 0.0&#10;    private var velocityLng: Double = 0.0&#10;&#10;    // Covariance matrix (variance/uncertainty)&#10;    private var varianceLat: Float = -1f&#10;    private var varianceLng: Float = -1f&#10;&#10;    // Time tracking&#10;    private var lastTimestamp: Long = 0&#10;&#10;    /**&#10;     * Process (predict) step - predicts state based on time elapsed&#10;     */&#10;    fun predict(timestamp: Long) {&#10;        if (lastTimestamp == 0L) {&#10;            lastTimestamp = timestamp&#10;            return&#10;        }&#10;&#10;        val dt = (timestamp - lastTimestamp) / 1000.0 // seconds&#10;        if (dt &lt;= 0 || dt &gt; 60) { // Ignore huge time gaps&#10;            lastTimestamp = timestamp&#10;            return&#10;        }&#10;&#10;        // Predict new position based on velocity&#10;        latitude += velocityLat * dt&#10;        longitude += velocityLng * dt&#10;&#10;        // Increase uncertainty due to process noise&#10;        if (varianceLat &gt; 0) {&#10;            varianceLat += processNoise * dt.toFloat()&#10;        }&#10;        if (varianceLng &gt; 0) {&#10;            varianceLng += processNoise * dt.toFloat()&#10;        }&#10;&#10;        lastTimestamp = timestamp&#10;    }&#10;&#10;    /**&#10;     * Update step - corrects prediction with GPS measurement&#10;     */&#10;    fun update(&#10;        measuredLat: Double,&#10;        measuredLng: Double,&#10;        accuracy: Float,&#10;        timestamp: Long&#10;    ) {&#10;        // Initialize state on first measurement&#10;        if (varianceLat &lt; 0) {&#10;            latitude = measuredLat&#10;            longitude = measuredLng&#10;            varianceLat = accuracy&#10;            varianceLng = accuracy&#10;            lastTimestamp = timestamp&#10;            return&#10;        }&#10;&#10;        // Measurement variance (GPS accuracy)&#10;        val measurementVariance = accuracy&#10;&#10;        // Kalman Gain calculation&#10;        val kalmanGainLat = varianceLat / (varianceLat + measurementVariance)&#10;        val kalmanGainLng = varianceLng / (varianceLng + measurementVariance)&#10;&#10;        // Update state estimate&#10;        val innovationLat = measuredLat - latitude&#10;        val innovationLng = measuredLng - longitude&#10;&#10;        latitude += kalmanGainLat * innovationLat&#10;        longitude += kalmanGainLng * innovationLng&#10;&#10;        // Update velocity estimate (simple differentiation)&#10;        val dt = (timestamp - lastTimestamp) / 1000.0&#10;        if (dt &gt; 0 &amp;&amp; dt &lt; 60) {&#10;            velocityLat = innovationLat / dt&#10;            velocityLng = innovationLng / dt&#10;        }&#10;&#10;        // Update covariance (reduce uncertainty)&#10;        varianceLat *= (1 - kalmanGainLat)&#10;        varianceLng *= (1 - kalmanGainLng)&#10;&#10;        // Prevent variance from getting too small (numerical stability)&#10;        varianceLat = varianceLat.coerceAtLeast(accuracy * 0.001f)&#10;        varianceLng = varianceLng.coerceAtLeast(accuracy * 0.001f)&#10;    }&#10;&#10;    /**&#10;     * Decay confidence when GPS signal is lost&#10;     */&#10;    fun decayConfidence(decayRate: Float = 1.5f) {&#10;        varianceLat += decayRate&#10;        varianceLng += decayRate&#10;&#10;        // Cap maximum uncertainty&#10;        varianceLat = varianceLat.coerceAtMost(100f)&#10;        varianceLng = varianceLng.coerceAtMost(100f)&#10;    }&#10;&#10;    /**&#10;     * Get current filtered position&#10;     */&#10;    fun getLatitude(): Double = latitude&#10;    fun getLongitude(): Double = longitude&#10;    fun getAccuracy(): Float = ((varianceLat + varianceLng) / 2f).coerceAtLeast(1f)&#10;&#10;    /**&#10;     * Reset the filter&#10;     */&#10;    fun reset() {&#10;        varianceLat = -1f&#10;        varianceLng = -1f&#10;        velocityLat = 0.0&#10;        velocityLng = 0.0&#10;        lastTimestamp = 0&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package tech.titans.runwars.utils&#10;&#10;/**&#10; * Kalman Filter implementation for GPS coordinates (latitude/longitude).&#10; * Uses a 2D state vector [lat, lng] with velocity estimation.&#10; */&#10;class KalmanLatLong(&#10;    private var processNoise: Float = 0.5f // Q - process noise covariance&#10;) {&#10;    // State vector: [latitude, longitude]&#10;    private var latitude: Double = 0.0&#10;    private var longitude: Double = 0.0&#10;&#10;    // Velocity estimates (degrees per second)&#10;    private var velocityLat: Double = 0.0&#10;    private var velocityLng: Double = 0.0&#10;&#10;    // Covariance matrix (variance/uncertainty)&#10;    private var varianceLat: Float = -1f&#10;    private var varianceLng: Float = -1f&#10;&#10;    // Time tracking&#10;    private var lastTimestamp: Long = 0&#10;&#10;    /**&#10;     * Process (predict) step - predicts state based on time elapsed&#10;     */&#10;    fun predict(timestamp: Long) {&#10;        if (lastTimestamp == 0L) {&#10;            lastTimestamp = timestamp&#10;            return&#10;        }&#10;&#10;        val dt = (timestamp - lastTimestamp) / 1000.0 // seconds&#10;        if (dt &lt;= 0 || dt &gt; 60) { // Ignore huge time gaps&#10;            lastTimestamp = timestamp&#10;            return&#10;        }&#10;&#10;        // Predict new position based on velocity&#10;        latitude += velocityLat * dt&#10;        longitude += velocityLng * dt&#10;&#10;        // Increase uncertainty due to process noise&#10;        if (varianceLat &gt; 0) {&#10;            varianceLat += processNoise * dt.toFloat()&#10;        }&#10;        if (varianceLng &gt; 0) {&#10;            varianceLng += processNoise * dt.toFloat()&#10;        }&#10;&#10;        lastTimestamp = timestamp&#10;    }&#10;&#10;    /**&#10;     * Update step - corrects prediction with GPS measurement&#10;     */&#10;    fun update(&#10;        measuredLat: Double,&#10;        measuredLng: Double,&#10;        accuracy: Float,&#10;        timestamp: Long&#10;    ) {&#10;        // Initialize state on first measurement&#10;        if (varianceLat &lt; 0) {&#10;            latitude = measuredLat&#10;            longitude = measuredLng&#10;            varianceLat = accuracy&#10;            varianceLng = accuracy&#10;            lastTimestamp = timestamp&#10;            return&#10;        }&#10;&#10;        // Measurement variance (GPS accuracy)&#10;        val measurementVariance = accuracy&#10;&#10;        // Kalman Gain calculation&#10;        val kalmanGainLat = varianceLat / (varianceLat + measurementVariance)&#10;        val kalmanGainLng = varianceLng / (varianceLng + measurementVariance)&#10;&#10;        // Update state estimate&#10;        val innovationLat = measuredLat - latitude&#10;        val innovationLng = measuredLng - longitude&#10;&#10;        latitude += kalmanGainLat * innovationLat&#10;        longitude += kalmanGainLng * innovationLng&#10;&#10;        // Update velocity estimate (simple differentiation)&#10;        val dt = (timestamp - lastTimestamp) / 1000.0&#10;        if (dt &gt; 0 &amp;&amp; dt &lt; 60) {&#10;            velocityLat = innovationLat / dt&#10;            velocityLng = innovationLng / dt&#10;        }&#10;&#10;        // Update covariance (reduce uncertainty)&#10;        varianceLat *= (1 - kalmanGainLat)&#10;        varianceLng *= (1 - kalmanGainLng)&#10;&#10;        // Prevent variance from getting too small (numerical stability)&#10;        varianceLat = varianceLat.coerceAtLeast(accuracy * 0.001f)&#10;        varianceLng = varianceLng.coerceAtLeast(accuracy * 0.001f)&#10;    }&#10;&#10;    /**&#10;     * Decay confidence when GPS signal is lost&#10;     */&#10;    fun decayConfidence(decayRate: Float = 1.5f) {&#10;        varianceLat += decayRate&#10;        varianceLng += decayRate&#10;&#10;        // Cap maximum uncertainty&#10;        varianceLat = varianceLat.coerceAtMost(100f)&#10;        varianceLng = varianceLng.coerceAtMost(100f)&#10;    }&#10;&#10;    /**&#10;     * Get current filtered position&#10;     */&#10;    fun getLatitude(): Double = latitude&#10;    fun getLongitude(): Double = longitude&#10;    fun getAccuracy(): Float = ((varianceLat + varianceLng) / 2f).coerceAtLeast(1f)&#10;&#10;    /**&#10;     * Reset the filter&#10;     */&#10;    fun reset() {&#10;        varianceLat = -1f&#10;        varianceLng = -1f&#10;        velocityLat = 0.0&#10;        velocityLng = 0.0&#10;        lastTimestamp = 0&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/themes.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/themes.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;resources&gt;&#10;&#10;    &lt;style name=&quot;Theme.RunWars&quot; parent=&quot;android:Theme.Material.Light.NoActionBar&quot;&gt;&#10;        &lt;!-- Status bar color --&gt;&#10;        &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/white&lt;/item&gt;&#10;        &lt;!-- Navigation bar color --&gt;&#10;        &lt;item name=&quot;android:navigationBarColor&quot;&gt;@android:color/white&lt;/item&gt;&#10;        &lt;!-- Make status bar icons dark for light background --&gt;&#10;        &lt;item name=&quot;android:windowLightStatusBar&quot;&gt;true&lt;/item&gt;&#10;    &lt;/style&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;resources&gt;&#10;&#10;    &lt;style name=&quot;Theme.RunWars&quot; parent=&quot;android:Theme.Material.Light.NoActionBar&quot;&gt;&#10;        &lt;!-- Status bar color --&gt;&#10;        &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/white&lt;/item&gt;&#10;        &lt;!-- Navigation bar color --&gt;&#10;        &lt;item name=&quot;android:navigationBarColor&quot;&gt;@android:color/white&lt;/item&gt;&#10;        &lt;!-- Make status bar icons dark for light background --&gt;&#10;        &lt;item name=&quot;android:windowLightStatusBar&quot;&gt;true&lt;/item&gt;&#10;    &lt;/style&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>